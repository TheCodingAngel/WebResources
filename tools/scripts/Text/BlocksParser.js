// Parse the file with preparsed Unicode Character Database - it has code points and blocks:
// https://raw.githubusercontent.com/unicode-org/icu/master/icu4c/source/data/unidata/ppucd.txt
// More details about this file:
// https://unicode-org.github.io/icu/design/props/ppucd

// sc - Script: 
// gc - General Category
// ccc - Character Combining Class: Overlay, Below_Left, Above_Right, ...
// jt - joining type: Dual_Joining, Left_Joining, Right_Joining, ...
// SB: OLetter (LE), Extend (EX), Format (FO), Lower (LO), Upper (UP), Numeric (NU), ...
// WB: ALetter (LE), Format (FO), Numeric (NU), Katakana (KA), Newline (NL), ZWJ, CR, LF, ...
// IDS = ID_Start
// XIDC = XID_Continue
// XIDS = XID_Start

class BlocksParser {
    #prevRange;
    
    #longNames;
    // Usually block names contain the corresponding scripts but here are the exceptions
    #scripts = new Map([
        ["Phonetic_Ext", "Latin"],
        ["Number_Forms", "Latin"],
        ["Alphabetic_PF", "Hebrew"],
        ["Rumi", "Arabic"],
        
        ["CJK_Radicals_Sup", "Han"],
        ["Kangxi", "Han"],
        ["CJK_Ext_A", "Han"],
        ["CJK", "Han"],
        ["CJK_Compat_Ideographs", "Han"],
        ["Ideographic_Symbols", "Han"],
        ["CJK_Ext_B", "Han"],
        ["CJK_Ext_C", "Han"],
        ["CJK_Ext_D", "Han"],
        ["CJK_Ext_E", "Han"],
        ["CJK_Ext_F", "Han"],
        ["CJK_Ext_I", "Han"],
        ["CJK_Compat_Ideographs_Sup", "Han"],
        ["CJK_Ext_G", "Han"],
        ["CJK_Ext_H", "Han"],
    ]);
    #blocks = [];
    
    constructor(text) {
        let allLines = text.split("\n");
        this.#longNames = new Map();
        
        for (let line of allLines) {
            if (!line) continue;
            
            // Note - the lines with long names are before the block lines
            // With other words, the map is already filled when setting the first block
            if (line.startsWith("value;blk;")) {
                this._setLongName(line);
            } else if (line.startsWith("block;")) {
                this._setBlock(line);
            } else {
                continue;
            }
        }
    }
    
    toString() {
        let res = `//Generated by ${this.constructor.name} \n\nlet UnicodeBlocks = [\n`;
        for (let bl of this.#blocks) {
            res = res + '\t{"first": 0x' + bl.first.toString(16).toUpperCase().padStart(4, '0') + ', "name": "' + bl.name + '"},\n';
        }
        return res + "];\n";
    }
    
    _setLongName(line) {
        let items = line.split(";");
        this.#longNames.set(items[2], items[3].split("\r")[0].split("\n")[0]);
    }
    
    _setBlock(line) {
        let items = line.split(";");
        let range = this._getNumRange(items[1]);
        
        for(let i = 2; i < items.length - 1; i++) {
            let s = items[i];
            if (s.startsWith("blk=")) {
                if (this.#prevRange && this.#prevRange[1] + 1 < range[0]) {
                    let start = this.#prevRange[1] + 1;
                    this.#blocks.push({first: start, name: "Unassigned"});

                    // Put one "unassigned" block at the beginning of each plane
                    let nextPlane = Math.ceil(start / UnicodeBlock.CODEPOINTS_IN_PLANE);
                    start = nextPlane * UnicodeBlock.CODEPOINTS_IN_PLANE;
                    while (start < range[0]) {
                        this.#blocks.push({first: start, name: "Unassigned"});
                        start = start + UnicodeBlock.CODEPOINTS_IN_PLANE;
                    }
                }
                this.#blocks.push({first: range[0], name: this._getBlockName(s.substring(4))});
                break;
            }
        }
        
        this.#prevRange = range;
    }
    
    _getBlockName(name) {
        let longName = this.#longNames.get(name);
        let words = (longName ? longName : name).split("_");
        
        // "while" (instead of "for") loop because we change the array in the body
        let i = 0;
        while (i < words.length) {
            let current = words[i];
            
            switch (current) {
                case "For":
                    words[i] = "for";
                    break;
                case "And":
                    words[i] = "and";
                    break;
                case "Linear":
                    // Turn off automatic logic for "Linear" - it is fine in the definitions
                    break;
                case "Phags":
                    if (i + 1 < words.length) {
                        words[i] = "Phags-pa";
                        words.splice(i + 1, 1);
                    }
                    break;
                default:
                    if (i + 1 < words.length) {
                        let next = words[i + 1];
                        let isFollowedByChar = next.length == 1;
                        let isNextCharacterLast = (i + 1) == (words.length - 1);
                        if ((words[0] != "CJK" && isFollowedByChar && isNextCharacterLast) || !isNaN(parseInt(next))) {
                            words[i] = current + "-" + next;
                            words.splice(i + 1, 1);
                        }
                    }
                    break;
            }
            
            i++;
        }
        let res = words.join(" ");
        
        let script = this.#scripts.get(name);
        if (script) {
            res = res + " (" + script + ")";
        }
        
        return res;
    }
    
    _getNumRange(text) {
        let range = text.split("..");
        return [
            parseInt(range[0], 16),
            parseInt(range[1], 16)
        ];
    }
}
